>[大厂资深面试官 带你破解Android高级面试](https://coding.imooc.com/class/317.html) 笔记

# 3 熟悉并发编程

---
## 3.1 如何停止一个线程

#### 考察什么？

- 是否对线程的用法有所了解？（初级）
- 是否对线程的 stop 方法有所了解（初级）
- 是否对线程 stop 过程中存在的问题有认识（中级）
- 是否熟悉 interupt 中断的用法（中级）
- 是否能解释清楚使用 boolean 标志位的好处（高级）
- 是否知道 interrupt 底层的细节（高级）
- 通过该题目能否将话题转移到线程安全，并阐述无误（高级）

#### 题目剖析

如何停止一个线程

- 官方停止线程的方法被废弃，所以不能直接简单的停止线程
- 如何设计可以随时被终端而取消的任务线程

**为什么不能直接简单的停止线程**：

- 线程可能在占用某些资源，如果直接停止，那么其占用的资源将无法被使用。
- 线程的直接终止，将导致逻辑上的不确定性（某些逻辑执行到一半），很容易造成问题。

**协作的任务执行模式**：

- 通过目标线程自行结束，而不是强制停止。
- 目标线程应该处理中断的能力。
- 中断方式：
  - interrupt 方式
  - boolean 标志位

**interrupt 方式**：

- 原生支持
- 使用 `interrupted()` 方法和 `interrupt()` 方法
- interrupted 和 isInterrupted 方法的区别
  - interrupted 静态方法，获取当前线程的中断状态，并清空。
  - isInterrupted 实例方法，获取该线程的中断状态，不清空。
- interrupted 状态，在 JNI 底层是被加锁保护的。

```java
for(int i = 0; i < 1000000; i++){
    if(interrupted()){
        break;
    }
}
```

**boolean 标志位**：

- 注意使用 volatile 修饰标志位。
- 性能上个更好，不需要 JNI 调用。

---
## 3.2 如何写出线程安全的程序

### 考察什么？

- 是否对线程安全有初步了解（初级）
- 是否线程安全产生的原因有所思考（中级）
- 是否知道 final、volatile 关键字的作用（中级）
- 是否清楚 1.5 之前 Java DCL 为什么有缺陷（中级）
- 是否清楚地知道如何编写线程安全的程序（高级）
- 是否对 ThreadLocal 的使用注意事项有认识（高级）

### 题目剖析

如何写出线程安全的程序

- 什么是线程安全？
- 如何实现线程安全？

**什么是线程安全**？

- 线程安全只关注可变可共享的内存
- 线程有自己的工作内存
- 对变量的操作不是原子性的

**如何实现线程安全**？

- 不共享资源
  - ThreadLocal
- 共享不可变资源
  - final
- 工作可变资源
  - 可见性
  - 原子性
  - 禁止重排序

**ThreadLocal**：

- ThreadLcoal 存储的变量是绑定到线程上的
- 内部使用的是 ThreadLocalMap
- ThreadLocalMap 与 WeakHashMap 对比

---| ThreadLocalMap | WeakHashMap
--- | --- | ---
对象持有 | 弱引用 | 弱引用
对象 GC | 不影响 | 不影响
引用清除 | 1 主动移除<br/>2 线程退出时退出 | 1 主动移除<br/>2 GC后移除
Hash 冲突 | 开放地址法 | 单链表法
Hash 计算 | 神奇数字的倍数 | 对象 Hash 值再散列
使用场景 | 对象较少 | 通用

**ThreadLocal使用建议**：

- 声明为静态的 final 成员
- 避免存储大量对象
- 用完后及时移除对象

**final** 字段

- final 字段有禁止重排序的功能
- 不要在构造方法中暴露 final 字段

**volatile** 字段

- 保证可见性
- 禁止重排序

**JUC 工作包**

- lock 等
- atomic
- 并发容器

---
## 3.3 ConcurrentHashMap 如何支持并发访问

### 考察什么？

- 是否数量掌握线程安全的概念（高级）
- 是否深入理解 CHM 的各项并发优化原理（高级）
- 是否掌握锁的优化方法（高级）

### 题目剖析

- 并发访问即考察线程安全问题
- 回调 ConcurrentHashMap 的原理即可

**如果对 ConcurrentHashMap 不了解**：

- 分析 HashMap 为什么线程不安全
- 阐述说明你在编写并发程序时，你会怎么做

**CHM 的优化历程**：

- 1.5 分段锁，必要时加锁
  - hash(key)，高位找 segment 锁，低位找 `table[]`。
  - 如果使用整数作为 key，会导致 key 的分布极为不均匀，甚至退化为 HashTable。
- 1.6 优化二次 Hash 算法
  - single-word 二次 hash 优化
- 1.7 段懒加载，volatile & cas
  - getObjectVolatile() 保证锁的可见性
- 1.8 摒弃段，基于 HashMap 原理的并发实现

**CHM 如何计数**：

- JDK5-7 基于段元素个数求和，二次不同就加锁
- JDK8 引入 CounterCell，本质上也是分段计算

**CHM 的弱一致性**：

- 添加元素后不一定能马上读到
- 清空元素后可能仍然有元素
- 遍历之前的段元素的变化会读到
  - 遍历到 14，此时修改了 15，是可以读到 15 的变化的
- 遍历之后的段元素变化读不到
  - 遍历到 15，此时修改了 13，是不可以读到 13 的变化的
- 遍历时元素发生变化不抛异常

**HashTable 的问题**:

- 大锁：对 HashTable 整体加锁
- 长锁：直接对方法加锁
- 读写锁共用：只有一把锁，从头锁到尾

**CHM 的解法**：

- 小锁：分段锁(5-7)、桶节点锁(8)
- 短锁：先尝试获取，失败再加锁
- 分离读写锁：读失败再加锁(5-7)，volatile 读，CAS 写(7-8)

**锁的优化建议**：

- 长锁不如短锁
- 大锁不如小锁
- 共锁不如私锁
- 嵌套锁不如扁平锁
- 分离读写锁
- 粗化高频锁
- 消除无用锁，或用 volatile 代替

---
## 3.4 AtomicReference 和 AtomicReferenceFieldUpdater 有何区别

### 考察什么？

- 是否熟练掌握原子操作的概念（中级）
- 是否熟悉 AR 和 ARFU 这两个类的用法和原理（中级）
- 是否对 Java 对象的内存占用有认识（高级）
- 是否有较强的敏感度和深入探索的精神（高级）

### 题目剖析

- AtomicReference 的使用
  - AtomicReference 本身是对对象的引用，对应每个属性，都要创建一个 AtomicReference 对象。
  - 32 位和 64 位(启用指针压缩)，每次创建，都需要消耗 16 个字节的空间，不启用指针压缩的 64 位对象，占用 24 个字节。
- AtomicReferenceFieldUpdater 的使用
  - 需要将那些希望被原子更新的对象属性声明为 volatile。
  - AtomicReferenceFieldUpdater 使用时，不需要针对每个属性创建对象，由此节约了内存。
- BufferedInputStream 中有使用到 AtomicReferenceFieldUpdater。
- kotlin 中的 `val by lazy` 也有使用到 AtomicReferenceFieldUpdater。

---
## 3.5 如何在 Android 中写出优雅的异步代码

### 考察什么？

- 是否熟练编写异步同步代码（中级）
- 是否熟悉回调地狱（中级）
- 是否能够熟练使用 RxJava（中级）
- 是否对 Kotlin 协程有所了解（高级）
- 是否具备编写良好代码的意识和能力（高级）

### 题目剖析

如何在 Android 中写出优雅的异步代码

**什么是异步**：
  
- 取决于代码是否顺序执行，而不是线程数。
  
**为什么需要异步**：

- 提高 CPU 利用率（CPU密集型，IO密集型）
- 提升 GUI 程序的响应速度
- 异步不一定快、

**RxJava 异常处理**：

- 没有传入 onError 会导致程序崩溃
- 注意页面销毁时取消 RxJava
- AutoDispose 的使用

**kotlin 协程**：

- 将异步代码转变位同步代码
