# 《Java TCP/IP Socket编程》

## 1 计算机网络协议简介

计算机系统为实现程序的相互通讯提供了许多有用的抽象应用编程接口，这类应用编程接口程序Socket。

## 计算机网络、分组、报文协议

计算机网络由一组通过通信信道相互连接的机器组成，这些机器称为注解和路由器。

- 主机：运行应用程序的计算机
- 路由器；将信息从一个通讯信道传递或转发到应一个通讯信道
- 通信信道：将字节序列从一个主机传输到另一个主机的手段，比如有线电缆的以太网、无线的WIFI

相关概念：

- 信息：指由程序创建和解释的字节序列，在计算机网络中，这些字节序列被称为分组报文(packet)。
- 协议(protocol)：相当于相互通信的程序间达成的一种约定。
- TCP/IP协议族：人们设计用于解决不同协议来解决不同类型问题的一组协议，互联网使用的就是TCP/IP协议族。
- TPC/IP协议族主要的协议有：TCP传输控制协议，UDP数据报文协议。

网络分层：

- 事实证明，将各种协议分层组织是一种非常有用的措施
- 在TCP/IP协议族中，底层由基础的通信信道组成，比如以太网或调制解调器
- 信道由网络层使用，TCP/IP协议族中唯一属于网络层的协议是IP协议
- IP协议使两个主机的一系列通信信道和路由器看起来像是单独的一条主机到主机的信道
- IP协程的上层是传输层协议，常用的传输层协议有TCP、UDP
- TCP、UDP有一个共同的功能：寻址，IP协议只是将分组报文分发到不同的主机，很明显，还需要更细粒度的寻址
- TCP、UDP使用的协议地址叫做端口号，用于区分同一主机上不同的应用程序
- TCP、UDP也叫端到端协议，因为它们都是将数据从一个应用程序发送到另一个应用程序

### 关于地址

- 在TCP/IP协议族中，有两个部分的信息来指定一个应用程序：互联网地址和端口号
- IPV4的长度是32位，IPV6的长度是128位。8位组成一个字节，一个字节表示数字的范围是0-255
- 一个互联网地址可以定位一台主机，但是一个主机可以对于多个互联网地址
- 操作系统中，端口号的范围是1-66635
- 回环地址：每个版本的IP协议都定义了一些特殊用途的地址，回环地址就是其中之一，回环地址总是被分别到一个特殊的回环接口，该接口是一个虚拟设备，功能只是简单的将接收到的报文直接会发给发送者
- IPV4的回环地址是 `127.0.0.1`，IPV6的回环地址是 `0:0:0:0:0:0:0:1`

IPV4中的一些特殊用途的地址：

- 私有网络地址：所有以 10 或 192.168 开头的地址，以及第一个数是 172，第二个数是 16-31 的地址。这些地址不属于公共互联网的一部分
- 私有网络地址通常被用于在家庭或小型办公室中，这些地方通过 NAT(Network Address Translation 网络地址转换)设备连接到互联网
- NAT：功能就像一个路由器，转发分组报文时会转换报文中的地址和端口，私有地址端口对转换为共有地址端口对，这就使得一组主机能够有效的共享同一个IP地址
- NAT架构的私有有网络只能主动的访问互联网，而不能从公共互联网被访问到
- 多播地址：IPV4的多播地址第一个数字在 224-239 之间，IPV6的多播地址由 FF 开始

### 主机地址

DNS：即 Domain Name System， 是一个分布式数据库，它将易于记忆的互联网地址解析为真实的IP地址

## 套接字

Socket是一种抽象，应用程序通过它来发送和接收数据，就像应用程序打开一个文件句柄，将数据读写到稳定的存储器上一样。使用套接字可以将应用程序添加到网络中，并与处于同一个网络中的其他应用程序进行通讯。

不同的传输协议有不同的 Socket 实现，比如在Java中：

- ServerSocket/Socket 用于使用TCP协议通讯
- DatagramSocket/DatagramPacket 用于使用UDP协议通讯

## 2 基本套接字

- 网络接口：NetworkInterface
- 网络地址：InetAddress
- TCP通讯：ServerSocket/Socket，TCP是一种可靠的传输协议。
- UDP通讯：DatagramSocket/DatagramPacket，UDP是一种尽力而为且不保证数据到底顺序的协议。
- 多播：MulticastSocket

## 3 发送和接收数据

- TCP/IP协议族的唯一约束是，信息必须在块(chunk)中发送和接收
- 信息编码：`little-endan` 和 `big-endian`

## 4 进阶

- 迭代服务器：一线程迭代处理多用户请求
- 并行服务器：一客户一线程、线程池

### 一客户一线程的问题

- 每个线程都会消耗系统资源，创建一个线程将占用 CPU 周期。
- 每个线程都由自己的数据结构(栈)，栈需要销毁系统内存。
- 当一个线程阻塞时，JVM需要为其保存状态，选择另外的线程运行，并在上下文切换时恢复阻塞线程的状态。
- 随着线程数的增加，线程将消耗越来越多的系统资源，导致系统花费更多的时间来处理上下文切换和线程管理，更少的时间对连接进行管理。

使用线程池可以化解此类问题。

### 阻塞与超时

- write 方法会阻塞等待，直到最后一个字节成功写入到TCP实现的本地缓存中，如果可用的缓存空间比要写入的数据小，在 write() 方法调用返回前，必须把一些数据成功传输到另一端。write() 方法的阻塞总时间还是取决于接收端的应用程序，而且 Java 实现还没有提供任何使 write() 超时或其他线程将其打断的方法。
- 针对这类API，可以自行实现超时机制

### 控制默认行为

- keep-alive 机制，该机制在经过一段不活动时间后，将向另一个终端发送探测消息，如果另一端还处于活跃状态，它讲回复一个确认信息，如果经过几次尝试后没有收到另一端的确认消息，则终止发送探测消息，关闭套接字。
- 设置发送和接收缓冲区的大小：一旦创建了一个Socket或DatagramSocket，操作系统就会为其分配缓冲区以存放接收和要发送的数据。
- 设置超时：`setTimeout()`
- 设置消除缓存延迟：TCP协议会将发送的数据缓存起来直到足够多时才一次发送，`setTcpNoDelay(boolean)`可以禁用这种行为。
- 设置紧急数据：TCP协议中包含了紧急数据概念，参考`sendUrgentData(int) getOOBInline() setOOBInline`方法
- 关闭后停留：当调用 close 方法后，即使套接字的缓冲区中还有未发送的数据，它也会立即返回，这样不发送完所有的数据可能导致主机发生故障，使用`setSoLinger()`方法可以选择让 close 后阻塞一段时间，直到所有数据发送完毕并确认，或发生了超时。
- 广播许可：一些操作系统要求显示的对广播许可进行请求：`setBroadcast(boolean)`
- 设置通信等级：`setTrafficClass(int tc)`
- 基于性能的协议选择：`setPerformancePreferences(int connectionTime, int latency, int bandwidth)`

### 告知另一端传输完成

- shutdownInput，未读取的数据将会被丢弃，读取操作返回 -1
- shutdownOutput，通讯的另一端的读取操作将返回 -1

## 5 NIO

### 为什么需要NIO

如果使用线程池来做并发处理会有以下问题：

线程开销方面：

- 创建、维护、切换线程需要系统开销
- 一客户一线称方式在系统扩展性方面受到了限制
- 虽然使用线程池可以节省创建线程的开销，同时允许实现者利用并行硬件的优势，但是对于**连接生存期比较长**的协议来说，线程池的大小仍然限制了系统可以同时的处理客户端数量。

扩展性方面：

- 程序员几乎不能对什么时候哪个线程获得服务进行控制
- 每个客户端都与其他客户端相互独立，客户端之间没有交互，也不会影响服务器状态，然后真实的场景要求所有客户直接共享某些状态信息，并且共享信息的是同步的，这要求共享信息的操作必须加上同步机制，这加剧了编程的复杂性，并进一步加剧了线程上下文切和系统调度的开销

NIO 提供了什么？

- 单线程非阻塞式的编程模型

## 6 深入剖析

略

## 引用

- 《Java TCP/IP Socket编程》
- [Java TCP/IP Socket 编程](http://wiki.jikexueyuan.com/project/java-socket/)
