# [左耳听风](https://time.geekbang.org/column/intro/48)——程序中的错误处理整理

原文：

- [1 程序中的错误处理：错误返回码和异常捕捉](https://time.geekbang.org/column/article/675)
- [2 程序中的错误处理：异步编程以及我的最佳实践](https://time.geekbang.org/column/article/693)

异常在编程中在所难免，如何处理好异常并不是一件易事，而 **熟练掌握常见的错误处理方式、熟悉不同语言的错误处理机制和风格** 有助于我们较好地错误处理程序中可能的异常。

## 1 程序的异常处理：错误码和异常捕获

### 1.1 传统的异常处理：错误码

1. 处理错误最直接的方式是通过一个全局的错误码，这也是传统的方式，在过程式语言中通常都是用这样的方式处理错误的。比如 C 语言，基本上来说，其`通过函数的返回值标识是否有错，然后通过全局的 errno 变量并配合一个 errstr 的数组来告诉你为什么出错`。
2. 这种用 `返回值 + errno` 的错误检查方式存在的问题是:
   1. 程序员一不小心就会忘记返回值的检查，而造成代码的 Bug；
   2. 函数接口非常不纯洁，正常值和错误值混淆在一起，导致语义有问题。
3. 针对以上问题，后面又有类库尝试区分错误值与返回值混淆，比如，Windows 的系统调用。使用 HRESULT 的返回来统一错误的返回值，这样可以明确函数调用时的返回值是成功还是错误，然后函数的 input 和 output 通过函数的参数来完成，于是出现了所谓的 入参 和 出参 这样的区别。这种方式使得函数变得复杂，而且没有解决函数的成功或失败可以被人为忽略的问题。

### 1.2 多返回值

有一些语言通过多返回值来解决传统错误检查繁琐的问题，比如 Go 语言，Go 语言的很多函数都会返回 `result, err` 两个值。

### 1.3 资源清理

程序出错时需要对已分配的一些资源做清理，在清理方式这在不同语言中有不同的体现：

- C 语言中可以使用 **goto** 直接跳转到定义好的资源清理逻辑段中，这样的处理方式虽然可以，但是会有潜在的问题。最主要的一个问题就是——你不能在中间的代码中有 return 语句（goto 之前就 return 了），因为你需要清理资源。在维护这样的代码时需要非常小心，因为一不注意就会导致代码有资源泄漏的问题。
- C++ 的 RAII（Resource Acquisition Is Initialization）机制使用面向对象的特性可以容易地处理这个事情。RAII 其实使用 C++ 类的机制，**在构造函数中分配资源，在析构函数中释放资源**。
- 在 Go 语言中，使用 **defer** 关键字也可以做到资源清理的效果。
- Java 使用下面的异常捕捉机制。

### 1.4 异常捕捉机制

上面 `错误检查` 和 `程序出错后对资源的清理` 这两个事。能把这个事做得比较好的其实是 `try - catch - finally` 这个编程模式。

```java
try {
    ... // 正常的业务代码
} catch (Exception1 e) {
    ... // 处理异常 Exception1 的代码
} catch (Exception2 e) {
    ... // 处理异常 Exception2 的代码
} finally {
    ... // 资源清理的代码
}
```

把正常的代码、错误处理的代码、资源清理的代码分门别类，看上去非常干净。`try - catch - finally` 这样的异常处理方式有如下一些好处：

- 函数接口在 input（参数）和 output（返回值）以及错误处理的语义是比较清楚的。
- 正常逻辑的代码可以与错误处理和资源清理的代码分开，提高了代码的可读性。（个人理解：一定程度上）
- 异常不能被忽略（如果要忽略也需要 catch 住，这是显式忽略）。（个人理解：这可以让维护者更清晰的明白设计者的意图，而不用猜测其是忘记了异常处理还是主动忽略）
- 在面向对象的语言中（如 Java），异常是个对象，所以，可以实现多态式的 catch。
- 与状态返回码相比，异常捕捉有一个显著的好处是，函数可以 **嵌套调用**，或是 **链式调用**。比如：`int x = add(a, div(b,c)); 或 Pizza p = PizzaBuilder().SetSize(sz) .SetPrice(p)...;` 在需要返回码的情况下，这事儿有点难做。

**对性能的考虑**：

- 异常捕捉的确是对性能有影响的，那是因为一旦异常被抛出，函数也就跟着 return 了。而程序`在执行需要处理函数栈上的上下文`，这会导致性能变得很慢，尤其是函数栈比较深的时候。但从另一方面来说，异常的抛出基本上表明程序的错误。程序在绝大多数情况下，应该是在没有异常的情况下运行的，所以，有异常的情况应该是少数的情况，不会影响正常处理的性能问题。
- 但总得来说，在遇到性能问题时，异常处理也是需要考虑的点，因为 Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。当我们的服务出现反应变慢、吞吐量下降的时候，检查发生最频繁的 Exception 也是一种思路。

**`try - catch - finally` 存在的致命问题**：在异步运行的世界里的问题。try 语句块里的函数运行在另外一个线程中，其中抛出的异常无法在调用者的这个线程中被捕捉。

### 1.5 错误返回码 vs 异常捕捉，如何选择？

错误返回码 vs 异常捕捉，各有优势，**从场景上来讨论使用哪种方式处理异常才是正确的姿势**。

错误类型有很多种，不同的错误需要有不同的处理方式。但错误处理是有一些通用的规则的。所以对编程中的各种错误类型进行整体的分类，有助于我们选择正确的错误处理方式。

- **资源的错误**。当我们的代码去请求一些资源时导致的错误，比如打开一个没有权限的文件， 写文件时出现的写错误，发送文件到网络端发现网络故障的错误，等等。这一类错误属于程序运行环境的问题。对于这类错误，有的，我们可以处理，有的我们则无法处理。比如，内存耗尽、栈溢出或是一些程序运行时关键性资源不能满足时，我们只能停止运行，甚至退出整个程序。
- **程序的错误**。比如：空指针、非法参数等。这类是我们自己程序的错误，我们要记录下来， 写入日志，最好触发监控系统报警。
- **用户的错误**。比如：Bad Request、Bad Format 等这类由用户的不合法输入带来的错误。 这类错误基本上是在用户的 API 层上出现的问题。比如，解析一个 XML 或 JSon 文件，或是用户输入的字段不合法之类的。对于这类问题，我们需要向用户端报错，让用户自己处理修正他们的输入或操作。然后，我们正常执行，但是需要做统计，统计相应的错误率，这样有利我们改善软件或是侦测是否有恶意的用户请求。

这三类错误中：

- 有些是我们希望杜绝发生的，比如程序的 Bug
- 有些则是我们杜绝不了的，比如用户的输入。
- 对于程序运行环境中的一些错误，则是我们希望可以恢复的。 也就是说，我们希望可以通过重试或是妥协的方式来解决这些环境的问题，比如重建网络连接， 重新打开一个新的文件。

对其进行安装一定的逻辑的分类：

- 对于我们并不期望会发生的事，我们可以使用异常捕捉——比如如果你的函数参数传入的对象不是一个 null 对象，那么，一旦传入后，可以抛异常，因为我们并不期望总是会发生这样的事。
- 对于我们觉得可能会发生的事，使用返回码——比如而对于一个需要检查用户输入信息是否正确的事，比如： 电子邮箱的格式，我们用返回码可能会好一些。

所以，对于上面三种错误的种类来说：

- 程序中的错误，可能用异常捕捉会比较合适；
- 用户的错误，用返回码比较合适；
- 资源类的错误，要分情况，是用异常捕捉还是用返回值，要看这事是不应该出现的，还是经常出现的。

当然，这只是一个大致的实践原则，并不代表所有的事都需要符合这个原则。除了 `用错误的分类来判断` 是否用返回码还是用异常捕捉之外，我们还要从 `程序设计的角度` 来考虑哪种情况下使用异常捕捉更好，哪种情况下使用返回码更好。因为异常捕捉在编程上的好处比函数返回值好很多，所以很多使用异常捕捉的代码会更易读也更健壮一些。而返回码容易被忽略， 所以，使用返回码的代码需要做良好的测试才能得到更好的质量。

不过，我们也要知道，在某些情况下，你只能使用其中的一个，比如：

- 在 C++ **重载操作符** 的情况下，你就很难使用错误返回码，只能抛异常；
- 异常捕捉只能在同步的情况下使用，在 **异步模式** 下，抛异常这事就不行了，需要通过检查子进程退出码或是回调函数来解决；
- 在分布式的情况下，调用远程服务只能看错误返回码，比如 HTTP 的返回码。

所以，在大多数情况下，我们会混用这两种报错的方式，有时候，我们还会把异常转成错误码 （比如 HTTP 的 RESTful API），也会把错误码转成异常（比如对系统调用的错误）。

总之，“报错的类型” 和 “错误处理” 是紧密相关的，错误处理方法多种多样，而且会在不同的层面上处理错误。

- 有些底层错误就需要自己处理掉（比如：底层模块会自动重建网络连接）。
- 有一些错误需要更上层的业务逻辑来处理（比如：重建网络连接不成功后只能让上层业务来处 理怎么办？降级使用本地缓存还是直接报错给用户，等等）。

所以，不同的错误类型再加上不同的错误处理会导致我们代码组织层面上的不同（也就是说，使用错误码还是异常捕捉主要还是看我们我们的错误处理流程以及代码组织怎么写会更清楚）。

### 1.6 总结

1. 程序错误处理的方式：错误码和异常捕获。
2. 错误处理关注的问题：
   1. 能方便地进行错误检测。
   2. 出现错误是能够通过一定机制进行资源回收。
   3. 错误处理有精确的语义，比如对于没有处理的异常，能够看出主动忽略异常还是其忘记检测了。
3. 错误码方式：通过一个全局的错误码表示错误，通过函数的返回值标识是否有错，然后通过全局的 errno 变量并配合一个 errstr 的数组来告诉你为什么出错。这种方式的缺点是：
   1. 程序员一不小心就会忘记返回值的检查，而造成代码的 Bug；
   2. 函数接口非常不纯洁，正常值和错误值混淆在一起，导致语义有问题。
4. 异常捕获方式： `try - catch - finally`：
   1. 优点：
      1. `try - catch - finally` 能较好地处理 `错误检查` 和 `程序出错后对资源的清理`。把正常的代码、错误处理的代码、资源清理的代码分门别类，看上去非常干净。
      2. 异常不能被忽略（如果要忽略也需要 catch 住，这是显式忽略）。这可以让维护者更清晰的明白设计者的意图，而不用猜测其是忘记了异常处理还是主动忽略）。
   2. 缺点：
      1. 在异步运行的世界里的问题。try 语句块里的函数运行在另外一个线程中，其中抛出的异常无法在调用者的这个线程中被捕捉。
      2. Java 每实例化一个 Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。
      3. 资源清理也比较方面。
5. 特定的场景下，只能使用特定的异常处理方式，这是业务场景或者语言本身的局限。
6. 对于两种异常处理方式都可以使用的场景，则需要进行具体分析，比如：
   1. 对于我们并不期望会发生的事，我们可以使用异常捕捉。
   2. 对于我们觉得可能会发生的事，使用返回码。
   3. 除以上两点外，除了 `用错误的分类来判断` 是否用返回码还是用异常捕捉之外，我们还要从 `程序设计的角度` 来考虑哪种情况下使用异常捕捉更好，哪种情况下使用返回码更好。

---

## 2 异步编程和最佳实践

在异步编程的世界里，因为被调用的函数是被放到了另外一个线程里运行，这将导致：

- 无法使用返回码。因为函数在被异步运行中，**所谓的返回只是把处理权交给下一条指令**，而不是把函数运行完的结果返回。所以，函数返回的语义完全变了，返回码也没有用了。
- 无法使用抛异常的方式。因为除了上述的函数立马返回的原因之外，**抛出的异常也在另外一个线程中，不同线程中的栈是完全不一样的**，所以主线程的 catch 完全看不到另外一个线程 中的异常。

异步编程的错误处理，也有许多方式，常见的则是 callback 形式，在做异步请求的时候，注册几个 `OnSuccess()、 OnFailure()` 这样的回调函数，让在另一个线程中运行的异步代码来回调过来。

### 2.1 各种语言的异步编程的错误处理

#### JavaScript 异步编程的错误处理

回调方式的好处与局限：

- 通过注册错误处理的回调函数，让异步执行的函数在出错的时候，调用被注册进来的错误处理函数，这样的方式比较好地解决了程序的错误处理。而出错的语义从返回码、异常捕捉到了`直接耦合错误出处函数的样子`。
- 但是， 如果我们需要把`几个异步函数顺序执行`的话（异步程序中，程序执行的顺序是不可预测的、也是不确定的，而有时候，函数被调用的上下文是有相互依赖的，所以，我们希望它们能按一定的顺序处理），就会出现了所谓的 Callback Hell 的问题。而这样层层嵌套中需要注册的错误处理函数也有可能是完全不一样的，而且会导致代码非常混乱，难以阅读和维护。

所以，一般来说，在异步编程的实践里，我们会用 Promise 模式来处理：

```javascript
doSomething()
.then(result => doSomethingElse(result))
.then(newResult => doThirdThing(newResult))
.then(finalResult => {  
    console.log(`Got the final result: ${finalResult}`);
})
.catch(failureCallback);
```

上面代码中的 `then()` 和 `catch()` 方法就是 Promise 对象的方法，`then(`)方法可以把各个异 步的函数给串联起来，而`catch()` 方法则是出错的处理。Promise 的功能还不止如此，比如 Promise 还可以同时等待两个不同的异步方法。

```javascript
promise1 = doSomething();
promise2 = doSomethingElse();
Promise.when(promise1, promise2)
.then(function (result1, result2) {
    ... // 处理 result1 和 result2 的代码
}, handleError);
```

在 ECMAScript 2017 的标准中，我们还可以使用 `async/await` 这两个关键字来取代 Promise 对象，这样可以让我们的代码更易读。

#### Java 异步编程的 Promise 模式

在 Java 中，在 JDK 1.8 里也引入了类 JavaScript 的玩法 —— CompletableFuture。这个类提供了大量的异步编程中 Promise 的各种方式。

#### Go 语言的 Promise

在 Go 语言中，如果你想实现一个简单的 Promise 模式，也是可以的。

### 2.2 补充

### ReactiveX

除了以上作者介绍的异常处理方式外，个人感觉 ReactiveX 也算是一种，ReactiveX 统一了异步编程的接口，异步调度的结果统一传递到下游 Subscriber 中处理。

### 协程

协程可以将异步代码转换为同步的编写形势，此时我们可以使用 try-catch 方式进行异常处理。

---

## 3 错误处理的最佳实践

- **统一分类的错误字典**。无论你是使用错误码还是异常捕捉，都需要认真并统一地做好错误的分类。最好是在一个地方定义相关的错误。比如，HTTP 的 4XX 表示客户端有问题，5XX 则表示服务端有问题。也就是说，你要建立一个错误字典。
- **同类错误的定义最好是可以扩展的**。这一点非常重要，而对于这一点，通过面向对象的继承 或是像 Go 语言那样的接口多态可以很好地做到。这样可以方便地重用已有的代码。
- **定义错误的严重程度**。比如，Fatal 表示重大错误，Error 表示资源或需求得不到满足， Warning 表示并不一定是个错误但还是需要引起注意，Info 表示不是错误只是一个信息， Debug 表示这是给内部开发人员用于调试程序的。
- **错误日志的输出最好使用错误码**，而不是错误信息。打印错误日志的时候，除了要用统一的格式，最好不要用错误信息，而使用相应的错误码，错误码不一定是数字，也可以是一个能 从错误字典里找到的一个唯一的可以让人读懂的关键字。这样，会非常有利于日志分析软件 进行自动化监控，而不是要从错误信息中做语义分析。比如：HTTP 的日志中就会有 HTTP 的返回码，如：404。但我更推荐使用像 PageNotFound 这样的标识，这样人和机器都很容易处理。
- 忽略错误最好有日志。不然会给维护带来很大的麻烦。
- **对于同一个地方不停的报错，最好不要都打到日志里**。不然这样会导致其它日志被淹没了，也会导致日志文件太大，最好的实践是，打出一个错误以及出现的次数。
- **不要用错误处理逻辑来处理业务逻辑**。也就是说，不要使用异常捕捉这样的方式来处理业务逻辑，而是应该用条件判断。如果一个逻辑控制可以用 if - else 清楚地表达，非常不建议使用异常方式处理。异常捕捉是用来处理不期望发生的事的，而错误码则用来处理可能会发生的事。
- **对于同类的错误处理，用一样的模式**。比如，对于 null 对象的错误，要么都用返回 null，加上条件检查的模式，要么都用抛 NullPointerException 的方式处理。不要混用，这样有助于代码规范。
- **尽可能在错误发生的地方处理错误**。因为这样会让调用者变得更简单。
- **向上尽可能地返回原始的错误**。如果一定要把错误返回到更高层去处理，那么，应该返回原始的错误，而不是重新发明一个错误。
- **处理错误时，总是要清理已分配的资源**。这点非常关键，使用 RAII 技术，或是 try-catch-finally，或是 Go 的 defer 都可以容易地做到。
- **不推荐在循环体里处理错误**。这里说的更多的情况是对于 try-catch 这种情况，对于绝大多数的情况你不需要这样做。最好把整个循环体外放在 try 语句块内，而在外面做 catch
- **不要把大量的代码都放在一个 try 语句块内**。一个 try 语句块内的语句应该是完成一个简单单一的事情。
- **为你的错误定义提供清楚的文档以及每种错误的代码示例**。如果你是做 RESTful API 方面的，使用 Swagger 会帮你很容易搞定这个事。
- **对于异步的方式，推荐使用 Promise 模式处理错误**。对于这一点，JavaScript 中有很好的实践。
- **对于分布式的系统，推荐使用 APM 相关的软件**。尤其是使用 Zipkin 这样的服务调用跟踪的 分析来关联错误。
